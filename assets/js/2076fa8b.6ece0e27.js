"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[587],{49164:n=>{n.exports=JSON.parse('{"functions":[{"name":"Constructor","desc":":::info Puzzle constructors are special\\nConstructors are returned by the module and called like *local functions* instead of acting like class functions.\\n\\n```lua\\nlocal signal = Signal()\\n```\\n:::","params":[{"name":"destroyOnLastConnection","desc":"","lua_type":"true?"}],"returns":[{"desc":"","lua_type":"Signal"}],"function_type":"static","tags":["Constructor"],"source":{"line":240,"path":"src/Signal.lua"}},{"name":"Wrap","desc":"Constructs a new Signal that wraps around an RBXScriptSignal.\\n\\n```lua\\nlocal signal = Signal.Wrap(workspace.ChildAdded)\\n\\nsignal:Connect(function(instance)\\n\\tprint(instance.Name .. \\" added\\")\\nend)\\n\\nInstance.new(\\"Part\\", workspace)\\n```","params":[{"name":"rbxScriptSignal","desc":"Existing RBXScriptSignal to wrap","lua_type":"RBXScriptSignal"}],"returns":[{"desc":"","lua_type":"Signal"}],"function_type":"static","source":{"line":270,"path":"src/Signal.lua"}},{"name":"Connect","desc":"Connects a function to the signal, which will be called anytime the signal is fired.\\n\\n```lua\\nsignal:Connect(function(message, number)\\n\\tprint(message, number)\\nend)\\n\\nsignal:Fire(\\"Hello\\", 25)\\n```","params":[{"name":"callback","desc":"","lua_type":"Callback"}],"returns":[{"desc":"","lua_type":"Connection"}],"function_type":"method","source":{"line":301,"path":"src/Signal.lua"}},{"name":"Once","desc":"Connects a function to the signal, which will be called the next time the signal fires. Once\\nthe connection is triggered, it will disconnect itself.\\n\\n```lua\\nsignal:Once(function(message, number)\\n\\tprint(message, number)\\nend)\\n\\nsignal:Fire(\\"Hello\\", 25)\\nsignal:Fire(\\"This message will not go through\\", 10)\\n```","params":[{"name":"callback","desc":"","lua_type":"Callback"}],"returns":[{"desc":"","lua_type":"Connection"}],"function_type":"method","source":{"line":333,"path":"src/Signal.lua"}},{"name":"GetConnections","desc":"Gets all connections from the signal.\\n\\n```lua\\nsignal:Connect(function(A) end)\\nsignal:Connect(function(B) end)\\n\\nprint(#signal:GetConnections()) -- 2\\n```","params":[],"returns":[{"desc":"","lua_type":"{Connection}"}],"function_type":"method","source":{"line":365,"path":"src/Signal.lua"}},{"name":"DisconnectAll","desc":"Disconnects all connections from the signal.\\n\\n```lua\\nsignal:Connect(function(A) end)\\nsignal:Connect(function(B) end)\\n\\nsignal:DisconnectAll()\\n```","params":[],"returns":[],"function_type":"method","source":{"line":393,"path":"src/Signal.lua"}},{"name":"Fire","desc":"Fire the signal, which will call all of the connected functions with the given arguments.\\n\\n```lua\\nsignal:Fire(\\"Hello\\")\\n\\n-- Any number of arguments can be fired:\\nsignal:Fire(\\"Hello\\", 32, {Test = \\"Test\\"}, true)\\n```","params":[{"name":"...","desc":"","lua_type":"any"}],"returns":[],"function_type":"method","source":{"line":425,"path":"src/Signal.lua"}},{"name":"FireDeferred","desc":"Same as [`Signal:Fire`](Signal#Fire), but uses [`task.defer`](https://create.roblox.com/docs/reference/engine/libraries/task#task.defer) internally & doesn\'t take advantage of thread reuse.\\n\\n```lua\\nsignal:FireDeferred(\\"Hello\\")\\n```","params":[{"name":"...","desc":"","lua_type":"any"}],"returns":[],"function_type":"method","source":{"line":454,"path":"src/Signal.lua"}},{"name":"Wait","desc":"Yields the current thread until the signal is fired, and returns the arguments fired from the signal.\\nYielding the current thread is not always desirable. If the desire is to only capture the next event\\nfired, using [`Signal:Once`](Signal#Once) might be a better solution.\\n\\n```lua\\ntask.spawn(function()\\n\\tlocal message, number = signal:Wait()\\n\\tprint(message, number) --\x3e \\"Hello\\", 32\\nend)\\n\\nsignal:Fire(\\"Hello\\", 32)\\n```","params":[],"returns":[{"desc":"","lua_type":"... any"}],"function_type":"method","yields":true,"source":{"line":483,"path":"src/Signal.lua"}},{"name":"Destroy","desc":"Cleans up the signal.\\n\\nTechnically, this is only necessary if the signal is created using\\n`Signal.Wrap`. Connections should be properly GC\'d once the signal\\nis no longer referenced anywhere. However, it is still good practice\\nto include ways to strictly clean up resources. Calling `Destroy`\\non a signal will also disconnect all connections immediately.\\n\\n```lua\\nsignal:Destroy()\\n```","params":[],"returns":[],"function_type":"method","source":{"line":519,"path":"src/Signal.lua"}}],"properties":[{"name":"_handlerListHead","desc":"","lua_type":"Connection | false","private":true,"source":{"line":157,"path":"src/Signal.lua"}},{"name":"_proxyHandler","desc":"","lua_type":"RBXScriptConnection?","private":true,"source":{"line":164,"path":"src/Signal.lua"}},{"name":"_destroyOnLastConnection","desc":"","lua_type":"true?","private":true,"source":{"line":171,"path":"src/Signal.lua"}}],"types":[{"name":"Callback","desc":"","lua_type":"(...any) -> ()","source":{"line":68,"path":"src/Signal.lua"}},{"name":"Connection","desc":"Represents a connection between a [Callback] and a [Signal].\\n```lua\\nlocal connection = signal:Connect(function() end)\\n\\nprint(connection.Connected) --\x3e true\\nconnection:Disconnect()\\nprint(connection.Connected) --\x3e false\\n```","fields":[{"name":"Connected","lua_type":"boolean","desc":""},{"name":"Disconnect","lua_type":"(Connection) -> ()","desc":"Method"}],"source":{"line":105,"path":"src/Signal.lua"}}],"name":"Signal","desc":"Signals allow events to be dispatched and handled.\\n\\n---\\n\\n```lua\\nlocal signal = Signal()\\n\\nsignal:Connect(function(message)\\n\\tprint(\\"Got message:\\", message)\\nend)\\n\\nsignal:Fire(\\"Hello world!\\")\\n```","source":{"line":220,"path":"src/Signal.lua"}}')}}]);