"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[133],{32137:e=>{e.exports=JSON.parse('{"functions":[{"name":"Component","desc":"Checks if the given value is a component. Additionally, check if the component data is a table by passing the second argument.","params":[{"name":"value","desc":"","lua_type":"any"},{"name":"dataIsTable","desc":"","lua_type":"boolean?"}],"returns":[{"desc":"","lua_type":"boolean"}],"function_type":"static","tags":["Assert"],"source":{"line":273,"path":"src/init.lua"}},{"name":"Assembler","desc":"Checks if the given value is an assembler.","params":[{"name":"assembler","desc":"","lua_type":"any"}],"returns":[{"desc":"","lua_type":"boolean"}],"function_type":"static","tags":["Assert"],"source":{"line":308,"path":"src/init.lua"}}],"properties":[{"name":"Signal","desc":"","lua_type":"Signal","readonly":true,"source":{"line":9,"path":"src/init.lua"}},{"name":"Assembler","desc":"","lua_type":"Assembler","readonly":true,"source":{"line":16,"path":"src/init.lua"}},{"name":"World","desc":"","lua_type":"World","readonly":true,"source":{"line":23,"path":"src/init.lua"}},{"name":"None","desc":"None is a unique symbol that replaces `nil` values in components. Some components may be used just as tags, with `data == nil`, but\\nmissing components are also internally shown as `nil`. None is used as a marker value in these cases.\\n\\nSince it is a unique table, `None` represents `nil` always and anywhere. If working with [World:Get], expected `nil` component values\\nwill appear as `None`.\\n\\n:::caution\\n```lua\\nlocal function ValueShouldBeNil(componentValue: Puzzle.None)\\n\\tif componentValue then\\n\\t\\t-- Normally, this conditional would have failed but None is a positive value\\n\\t\\tprint(\\"The component value is not nil but None!\\")\\n\\tend\\nend\\n```\\n:::","lua_type":"None","readonly":true,"source":{"line":47,"path":"src/init.lua"}}],"types":[{"name":"Component","desc":"","fields":[{"name":"data","lua_type":"T","desc":""},{"name":"name","lua_type":"string","desc":""}],"source":{"line":256,"path":"src/init.lua"}}],"name":"Types","desc":"Types serves as storage for types & functions used across the\\nlibrary. Internally, Types (**Puzzle**) is the parent of all the modules.\\n\\n---\\n\\nAll types used in Puzzle are exported for use in other modules which also re-export them, making it possible to use types both from this\\nmodule and from the required module. Scripts of the library modules are also exposed for them to be required.\\n\\nThis is a recommended structure for systems that run Puzzle:\\n\\n```lua\\nlocal Puzzle = require(Path.To.Puzzle)\\n\\n-- Note that returned modules by Puzzle are given as to-be required scripts\\nlocal Assembler = require(Puzzle.Assembler)\\nlocal World = require(Puzzle.World)\\n\\nlocal Assembler: Puzzle.Assembler<Color3> = Assembler \\"Color\\"\\n\\n-- If dealing with argument or variable types, use Puzzle.Type preferably\\nlocal function PuzzleWorld(world: Puzzle.World) end\\n\\n-- The main class can also be used for types but it looks odd\\nlocal function WorldWorld(world: World.World) end\\n```","source":{"line":77,"path":"src/init.lua"}}')}}]);